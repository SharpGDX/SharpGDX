using SharpGDX.Graphics;
using SharpGDX.Graphics.GLUtils;

namespace SharpGDX;

/// <summary>
///     This interface encapsulates communication with the graphics processor.
/// </summary>
/// <remarks>
///     <para>
///         Depending on the available hardware and the current <see cref="IApplication" /> configuration, access to
///         <see cref="IGL20" /> and <see cref="IGL30" /> are provided here.
///     </para>
///     <para>
///         If supported by the backend, this interface lets you query the available display modes (graphics resolution and
///         color depth) and change it.
///     </para>
///     <para>
///         This interface can be used to switch between continuous and non-continuous rendering (see
///         <see cref="SetContinuousRendering(bool)" />), and to explicitly <see cref="RequestRendering()" />.
///     </para>
///     <para>
///         There are many more utility classes that are not directly generated by the <see cref="IGraphics" /> interfaces.
///         See <see cref="VertexArray" />, <see cref="VertexBufferObject" />, <see cref="IndexBufferObject" />,
///         <see cref="Mesh" />, <see cref="ShaderProgram" /> and <see cref="FrameBuffer" />,
///         <see cref="Graphics.G2D.BitmapFont" />, <see cref="Graphics.G2D.IBatch" /> and so on.
///     </para>
///     <para>
///         All these classes are managed, meaning they don't need to be reloaded on a context loss.
///     </para>
/// </remarks>
public partial interface IGraphics
{
    /// <summary>
    ///     Returns whether OpenGL ES 3.0 is available.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If it is you can get an instance of <see cref="IGL30" /> via <see cref="GetGL30()" /> to access OpenGL ES 3.0
    ///         functionality.
    ///     </para>
    ///     <para>
    ///         Note that this functionality will only be available if you instructed the <see cref="IApplication" /> instance
    ///         to use OpenGL ES 3.0!
    ///     </para>
    /// </remarks>
    /// <returns>Whether OpenGL ES 3.0 is available.</returns>
    bool IsGL30Available();

    /// <summary>
    ///     Returns whether OpenGL ES 3.1 is available.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If it is you can get an instance of <see cref="IGL31" /> via <see cref="GetGL31()" /> to access OpenGL ES 3.1
    ///         functionality.
    ///     </para>
    ///     <para>
    ///         Note that this functionality will only be available if you instructed the <see cref="IApplication" /> instance
    ///         to use OpenGL ES 3.1!
    ///     </para>
    /// </remarks>
    /// <returns>Whether OpenGL ES 3.1 is available.</returns>
    bool IsGL31Available();

    /// <summary>
    ///     Returns whether OpenGL ES 3.2 is available.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         If it is you can get an instance of <see cref="IGL32" /> via <see cref="GetGL32()" /> to access OpenGL ES 3.2
    ///         functionality.
    ///     </para>
    ///     <para>
    ///         Note that this functionality will only be available if you instructed the <see cref="IApplication" /> instance
    ///         to use OpenGL ES 3.2!
    ///     </para>
    /// </remarks>
    /// <returns>Whether OpenGL ES 3.2 is available.</returns>
    bool IsGL32Available();

    /// <summary>
    ///     Returns the <see cref="IGL20" /> instance.
    /// </summary>
    /// <returns>The <see cref="IGL20" /> instance.</returns>
    IGL20 GetGL20();

    /// <summary>
    ///     Returns the <see cref="IGL30" />.
    /// </summary>
    /// <returns>The <see cref="IGL30" /> instance or <see langword="null" /> if not supported.</returns>
    IGL30? GetGL30();

    /// <summary>
    ///     Returns the <see cref="IGL31" /> instance.
    /// </summary>
    /// <returns>The <see cref="IGL31" /> instance or <see langword="null" /> if not supported.</returns>
    IGL31 GetGL31();

    /// <summary>
    ///     Returns the <see cref="IGL32" /> instance.
    /// </summary>
    /// <returns>The <see cref="IGL32" /> instance or <see langword="null" /> if not supported.</returns>
    IGL32? GetGL32();

    /// <summary>
    ///     Set the GL20 instance.
    /// </summary>
    /// <param name="gl20"></param>
    void SetGL20(IGL20 gl20);

    /// <summary>
    ///     Set the GL30 instance.
    /// </summary>
    /// <param name="gl30"></param>
    void SetGL30(IGL30 gl30);

    /// <summary>
    ///     Set the GL31 instance.
    /// </summary>
    /// <param name="gl31"></param>
    void SetGL31(IGL31 gl31);

    /// <summary>
    ///     Set the GL32 instance.
    /// </summary>
    /// <param name="gl32"></param>
    void SetGL32(IGL32 gl32);

    /// <summary>
    ///     Returns the width of the client area in logical pixels.
    /// </summary>
    /// <returns>The width of the client area in logical pixels.</returns>
    int GetWidth();

    /// <summary>
    ///     Returns the height of the client area in logical pixels.
    /// </summary>
    /// <returns>The height of the client area in logical pixels.</returns>
    int GetHeight();

    /// <summary>
    ///     Returns the width of the frame buffer in physical pixels.
    /// </summary>
    /// <returns>The width of the frame buffer in physical pixels.</returns>
    int GetBackBufferWidth();

    /// <summary>
    ///     Returns the height of the frame buffer in physical pixels.
    /// </summary>
    /// <returns>The height of the frame buffer in physical pixels.</returns>
    int GetBackBufferHeight();

    /// <summary>
    ///     Returns the amount of pixels per logical pixel (point).
    /// </summary>
    /// <returns>The amount of pixels per logical pixel (point).</returns>
    float GetBackBufferScale();

    /// <summary>
    ///     Returns the inset from the left which avoids display cutouts in logical pixels.
    /// </summary>
    /// <returns>The inset from the left which avoids display cutouts in logical pixels.</returns>
    int GetSafeInsetLeft();

    /// <summary>
    ///     Returns the inset from the top which avoids display cutouts in logical pixels.
    /// </summary>
    /// <returns>The inset from the top which avoids display cutouts in logical pixels.</returns>
    int GetSafeInsetTop();

    /// <summary>
    ///     Returns the inset from the bottom which avoids display cutouts or floating gesture bars, in logical pixels.
    /// </summary>
    /// <returns>The inset from the bottom which avoids display cutouts or floating gesture bars, in logical pixels.</returns>
    int GetSafeInsetBottom();

    /// <summary>
    ///     Returns the inset from the right which avoids display cutouts in logical pixels.
    /// </summary>
    /// <returns>The inset from the right which avoids display cutouts in logical pixels.</returns>
    int GetSafeInsetRight();

    /// <summary>
    ///     Returns the id of the current frame.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         The general contract of this method is that the id is incremented only when the application is in the running
    ///         state right before calling the <see cref="IApplicationListener.Render()" /> method.
    ///     </para>
    ///     <para>
    ///         The id of the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for 2
    ///         <sup>63</sup>-1 rendering cycles.
    ///     </para>
    /// </remarks>
    /// <returns>The id of the current frame.</returns>
    long GetFrameId();

    /// <summary>
    ///     Returns the time span between the current frame and the last frame in seconds.
    /// </summary>
    /// <returns>The time span between the current frame and the last frame in seconds.</returns>
    float GetDeltaTime();

    /// <summary>
    ///     Returns the average number of frames per second.
    /// </summary>
    /// <returns>The average number of frames per second.</returns>
    int GetFramesPerSecond();

    /// <summary>
    ///     Returns the <see cref="GraphicsType" /> of this Graphics instance.
    /// </summary>
    /// <returns>The <see cref="GraphicsType" /> of this Graphics instance.</returns>
    GraphicsType GetType();

    /// <summary>
    ///     Returns the <see cref="GLVersion" /> of this Graphics instance.
    /// </summary>
    /// <returns>The <see cref="GLVersion" /> of this Graphics instance.</returns>
    GLVersion GetGLVersion();

    /// <summary>
    ///     Returns the pixels per inch on the x-axis.
    /// </summary>
    /// <returns>The pixels per inch on the x-axis.</returns>
    float GetPpiX();

    /// <summary>
    ///     Returns the pixels per inch on the y-axis.
    /// </summary>
    /// <returns>The pixels per inch on the y-axis.</returns>
    float GetPpiY();

    /// <summary>
    ///     Returns the pixels per centimeter on the x-axis.
    /// </summary>
    /// <returns>The pixels per centimeter on the x-axis.</returns>
    float GetPpcX();

    /// <summary>
    ///     Returns the pixels per centimeter on the y-axis.
    /// </summary>
    /// <returns>The pixels per centimeter on the y-axis.</returns>
    float GetPpcY();

    /// <summary>
    ///     This is a scaling factor for the Density Independent Pixel unit.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Follows the same conventions as android.util.DisplayMetrics#density, where one DIP is one pixel on an
    ///         approximately 160 dpi screen. Thus, on a 160dpi screen this density value will be 1; on a 120 dpi screen it
    ///         would be .75; etc.
    ///     </para>
    ///     <para>
    ///         If the density could not be determined, this returns a default value of 1.
    ///     </para>
    ///     <para>
    ///         Depending on the underlying platform implementation this might be a relatively expensive operation. Therefore,
    ///         it should not be called continuously on each frame.
    ///     </para>
    /// </remarks>
    /// <returns>The Density Independent Pixel factor of the display.</returns>
    float GetDensity();

    /// <summary>
    ///     Whether the given backend supports a display mode change via calling <see cref="SetFullscreenMode(DisplayMode)" />.
    /// </summary>
    /// <returns>Whether display mode changes are supported or not.</returns>
    bool SupportsDisplayModeChange();

    /// <summary>
    ///     Returns the primary monitor.
    /// </summary>
    /// <returns>The primary monitor.</returns>
    Monitor GetPrimaryMonitor();

    /// <summary>
    ///     Returns the monitor the application's window is located on.
    /// </summary>
    /// <returns>The monitor the application's window is located on.</returns>
    Monitor GetMonitor();

    /// <summary>
    ///     Returns the currently connected <see cref="Monitor" />s.
    /// </summary>
    /// <returns>The currently connected <see cref="Monitor" />s.</returns>
    Monitor[] GetMonitors();

    /// <summary>
    ///     Returns the supported fullscreen <see cref="DisplayMode" />(s) of the monitor the window is on.
    /// </summary>
    /// <returns>The supported fullscreen <see cref="DisplayMode" />(s) of the monitor the window is on.</returns>
    DisplayMode[] GetDisplayModes();

    /// <summary>
    ///     Returns the supported fullscreen <see cref="DisplayMode" />s of the given <see cref="Monitor" />.
    /// </summary>
    /// <param name="monitor"></param>
    /// <returns>The supported fullscreen <see cref="DisplayMode" />s of the given <see cref="Monitor" />.</returns>
    DisplayMode[] GetDisplayModes(Monitor monitor);

    /// <summary>
    ///     Returns the current <see cref="DisplayMode" /> of the monitor the window is on.
    /// </summary>
    /// <returns>The current <see cref="DisplayMode" /> of the monitor the window is on.</returns>
    DisplayMode GetDisplayMode();

    /// <summary>
    ///     Returns the current <see cref="DisplayMode" /> of the given <see cref="Monitor" />.
    /// </summary>
    /// <param name="monitor"></param>
    /// <returns>The current <see cref="DisplayMode" /> of the given <see cref="Monitor" />.</returns>
    DisplayMode GetDisplayMode(Monitor monitor);

    /// <summary>
    ///     Sets the window to fullscreen mode.
    /// </summary>
    /// <param name="displayMode">The display mode.</param>
    /// <returns>Whether the operation succeeded.</returns>
    bool SetFullscreenMode(DisplayMode displayMode);

    /// <summary>
    ///     Sets the window to windowed mode.
    /// </summary>
    /// <param name="width">The width in pixels.</param>
    /// <param name="height">The height in pixels.</param>
    /// <returns>Whether the operation succeeded.</returns>
    bool SetWindowedMode(int width, int height);

    /// <summary>
    ///     Sets the title of the window.
    /// </summary>
    /// <remarks>
    ///     Ignored on Android.
    /// </remarks>
    /// <param name="title">The title.</param>
    void SetTitle(string title);

    /// <summary>
    ///     Sets the window decoration as enabled or disabled.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         On Android, this will enable/disable the menu bar.
    ///     </para>
    ///     <para>
    ///         Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for
    ///         the window to be recreated in order for the changes to take effect. Consult the documentation for the backend
    ///         in use for more information.
    ///     </para>
    ///     <para>
    ///         Supported on all GDX desktop backends and on Android (to disable the menu bar).
    ///     </para>
    /// </remarks>
    /// <param name="undecorated">true if the window border or status bar should be hidden. false otherwise.</param>
    void SetUndecorated(bool undecorated);

    /// <summary>
    ///     Sets whether the window should be resizable.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Ignored on Android.
    ///     </para>
    ///     <para>
    ///         Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for
    ///         the window to be recreated in order for the changes to take effect. Consult the documentation for the backend
    ///         in use for more information.
    ///     </para>
    ///     <para>
    ///         Supported on all GDX desktop backends.
    ///     </para>
    /// </remarks>
    /// <param name="resizable"></param>
    void SetResizable(bool resizable);

    /// <summary>
    ///     Enable/Disable vsync.
    /// </summary>
    /// <remarks>
    ///     This is a best-effort attempt which might not work on all platforms.
    /// </remarks>
    /// <param name="vsync">Vsync enable or not.</param>
    void SetVSync(bool vsync);

    /// <summary>
    ///     Sets the target frame rate for the application when using continuous rendering.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Might not work on all platforms.
    ///     </para>
    ///     <para>
    ///         Is not generally advised to be used on mobile platforms.
    ///     </para>
    /// </remarks>
    /// <param name="fps">
    ///     The targeted fps.
    ///     <remarks>
    ///         <para>
    ///             The default differs by platform.
    ///         </para>
    ///     </remarks>
    /// </param>
    public void SetForegroundFPS(int fps);

    /// <summary>
    ///     Returns the format of the color, depth and stencil buffer in a <see cref="BufferFormat" /> instance.
    /// </summary>
    /// <returns>The format of the color, depth and stencil buffer in a <see cref="BufferFormat" /> instance.</returns>
    BufferFormat GetBufferFormat();

    /// <summary>
    ///     Returns whether the extension is supported.
    /// </summary>
    /// <param name="extension">The extension name.</param>
    /// <returns>Whether the extension is supported.</returns>
    bool SupportsExtension(string extension);

    /// <summary>
    ///     Sets whether to render continuously.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In case rendering is performed non-continuously, the following events will trigger a redraw:
    ///         <list type="bullet">
    ///             <item>A call to <see cref="RequestRendering()" /></item>
    ///             <item> Input events from the touch screen/mouse or keyboard</item>
    ///             <item>
    ///                 A <see cref="Runnable" /> is posted to the rendering thread via
    ///                 <see cref="IApplication.PostRunnable(Runnable)" />. In the case of a multi-window app, all windows will
    ///                 request rendering if a runnable is posted to the application. To avoid this, post a runnable to the
    ///                 window instead.
    ///             </item>
    ///         </list>
    ///     </para>
    ///     <para>
    ///         Life-cycle events will also be reported as usual, see <see cref="IApplicationListener" />.
    ///     </para>
    ///     <para>
    ///         This method can be called from any thread.
    ///     </para>
    /// </remarks>
    /// <param name="isContinuous">Whether the rendering should be continuous or not.</param>
    void SetContinuousRendering(bool isContinuous);

    /// <summary>
    /// </summary>
    /// <returns>Whether rendering is continuous.</returns>
    bool IsContinuousRendering();

    /// <summary>
    ///     Requests a new frame to be rendered if the rendering mode is non-continuous.
    /// </summary>
    /// <remarks>
    ///     This method can be called from any thread.
    /// </remarks>
    void RequestRendering();

    /// <summary>
    ///     Whether the app is fullscreen or not.
    /// </summary>
    /// <returns></returns>
    bool IsFullscreen();

    /// <summary>
    ///     Create a new cursor represented by the <see cref="Pixmap" />.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         The Pixmap must be in RGBA8888 format, width & height must be powers-of-two greater than zero (not necessarily
    ///         equal) and of a certain minimum size (32x32 is a safe bet), and alpha transparency must be single-bit (i.e.,
    ///         0x00 or 0xFF only).
    ///     </para>
    ///     <para>
    ///         This function returns a Cursor object that can be set as the system cursor by calling
    ///         <see cref="SetCursor(ICursor)" />.
    ///     </para>
    /// </remarks>
    /// <param name="pixmap">The mouse cursor image as a <see cref="Pixmap" />.</param>
    /// <param name="xHotspot">The x location of the hotspot pixel within the cursor image (origin top-left corner).</param>
    /// <param name="yHotspot">The y location of the hotspot pixel within the cursor image (origin top-left corner).</param>
    /// <returns>
    ///     A cursor object that can be used by calling <see cref="SetCursor(ICursor)" /> or <see langword="null" /> if
    ///     not supported.
    /// </returns>
    ICursor NewCursor(Pixmap pixmap, int xHotspot, int yHotspot);

    /// <summary>
    ///     Only viable on the lwjgl-backend and on the gwt-backend.
    /// </summary>
    /// <param name="cursor"></param>
    void SetCursor(ICursor cursor);

    /// <summary>
    ///     Sets one of the predefined <see cref="ICursor.SystemCursor" />s.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Browsers that support cursor:url() and support the png format (the pixmap is converted to a data-url of type
    ///         image/png) should also support custom cursors. Will set the mouse cursor image to the image represented by the
    ///         <see cref="ICursor" />.
    ///     </para>
    ///     <para>
    ///         It is recommended to call this function in the main render thread, and maximum one time per frame.
    ///     </para>
    /// </remarks>
    /// <param name="systemCursor">The mouse cursor as an <see cref="ICursor" />.</param>
    void SetSystemCursor(ICursor.SystemCursor systemCursor);
}