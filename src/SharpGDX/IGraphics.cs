using SharpGDX.Graphics;
using SharpGDX.Graphics.GLUtils;

namespace SharpGDX
{
	/** This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current
 * {@link Application} configuration, access to {@link GL20} and {@link GL30} are provided here.
 * <p>
 * If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth)
 * and change it.
 * <p>
 * This interface can be used to switch between continuous and non-continuous rendering (see
 * {@link #setContinuousRendering(boolean)}), and to explicitly {@link #requestRendering()}.
 * <p>
 * There are many more utility classes that are not directly generated by the {@link Graphics} interfaces. See {@link VertexArray}
 * , {@link VertexBufferObject}, {@link IndexBufferObject}, {@link Mesh}, {@link ShaderProgram} and {@link FrameBuffer},
 * {@link BitmapFont}, {@link Batch} and so on. All these classes are managed, meaning they don't need to be reloaded on a context
 * loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.
 * @author mzechner */
	public partial interface IGraphics
	{
		/** Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of {@link GL30} via {@link #getGL30()} to
		 * access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the
		 * {@link Application} instance to use OpenGL ES 3.0!
		 *
		 * @return whether OpenGL ES 3.0 is available */
		bool IsGL30Available();

		/** Returns whether OpenGL ES 3.1 is available. If it is you can get an instance of {@link GL31} via {@link #getGL31()} to
		 * access OpenGL ES 3.1 functionality. Note that this functionality will only be available if you instructed the
		 * {@link Application} instance to use OpenGL ES 3.1!
		 *
		 * @return whether OpenGL ES 3.1 is available */
		bool IsGL31Available();

        /// <summary>
        /// Returns whether OpenGL ES 3.2 is available.
        /// </summary>
        /// <remarks>
        ///<para>
        ///If it is you can get an instance of <see cref="IGL32"/> via <see cref="GetGL32()"/> to access OpenGL ES 3.2 functionality.
        /// </para>
        /// <para>
        ///Note that this functionality will only be available if you instructed the <see cref="IApplication"/> instance to use OpenGL ES 3.2!
        /// </para>
        /// </remarks>
        /// <returns>Whether OpenGL ES 3.2 is available.</returns>
        bool IsGL32Available();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The {@link GL20} instance.</returns>
        IGL20 GetGL20();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The {@link GL30} instance or null if not supported.</returns>
        IGL30? GetGL30();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The {@link GL31} instance or null if not supported.</returns>
        IGL31 GetGL31();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The {@link GL32} instance or null if not supported.</returns>
        IGL32? GetGL32();

		/** Set the GL20 instance **/
		 void SetGL20(IGL20 gl20);

		/** Set the GL30 instance **/
		 void SetGL30(IGL30 gl30);

		/** Set the GL31 instance **/
		 void SetGL31(IGL31 gl31);

		/** Set the GL32 instance **/
		 void SetGL32(IGL32 gl32);

		/** @return the width of the client area in logical pixels. */
		int GetWidth();

		/** @return the height of the client area in logical pixels */
		int GetHeight();

		/** @return the width of the framebuffer in physical pixels */
		int GetBackBufferWidth();

		/** @return the height of the framebuffer in physical pixels */
		int GetBackBufferHeight();

		/** @return amount of pixels per logical pixel (point) */
		float GetBackBufferScale();

		/** @return the inset from the left which avoids display cutouts in logical pixels */
		int GetSafeInsetLeft();

		/** @return the inset from the top which avoids display cutouts in logical pixels */
		int GetSafeInsetTop();

		/** @return the inset from the bottom which avoids display cutouts or floating gesture bars, in logical pixels */
		int GetSafeInsetBottom();

		/** @return the inset from the right which avoids display cutouts in logical pixels */
		int GetSafeInsetRight();

		/** Returns the id of the current frame. The general contract of this method is that the id is incremented only when the
		 * application is in the running state right before calling the {@link ApplicationListener#render()} method. Also, the id of
		 * the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for 2<sup>63</sup>-1 rendering
		 * cycles.
		 * @return the id of the current frame */
		long GetFrameId();

		/** @return the time span between the current frame and the last frame in seconds. */
		float GetDeltaTime();
		
		/** @return the average number of frames per second */
		int GetFramesPerSecond();

		/** @return the {@link GraphicsType} of this Graphics instance */
		GraphicsType GetType();

		/** @return the {@link GLVersion} of this Graphics instance */
		GLVersion GetGLVersion();

		/** @return the pixels per inch on the x-axis */
		float GetPpiX();

		/** @return the pixels per inch on the y-axis */
		float GetPpiY();

		/** @return the pixels per centimeter on the x-axis */
		float GetPpcX();

		/** @return the pixels per centimeter on the y-axis. */
		float GetPpcY();

		/** This is a scaling factor for the Density Independent Pixel unit, following the same conventions as
		 * android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen
		 * this density value will be 1; on a 120 dpi screen it would be .75; etc.
		 *
		 * If the density could not be determined, this returns a default value of 1.
		 *
		 * Depending on the underlying platform implementation this might be a relatively expensive operation. Therefore it should not
		 * be called continously on each frame.
		 *
		 * @return the Density Independent Pixel factor of the display. */
		float GetDensity();

		/** Whether the given backend supports a display mode change via calling {@link Graphics#setFullscreenMode(DisplayMode)}
		 *
		 * @return whether display mode changes are supported or not. */
		bool SupportsDisplayModeChange();

		/** @return the primary monitor **/
		Monitor GetPrimaryMonitor();

		/** @return the monitor the application's window is located on */
		Monitor GetMonitor();

		/** @return the currently connected {@link Monitor}s */
		Monitor[] GetMonitors();

		/** @return the supported fullscreen {@link DisplayMode}(s) of the monitor the window is on */
		DisplayMode[] GetDisplayModes();

		/** @return the supported fullscreen {@link DisplayMode}s of the given {@link Monitor} */
		DisplayMode[] GetDisplayModes(Monitor monitor);

		/** @return the current {@link DisplayMode} of the monitor the window is on. */
		DisplayMode GetDisplayMode();

		/** @return the current {@link DisplayMode} of the given {@link Monitor} */
		DisplayMode GetDisplayMode(Monitor monitor);

		/** Sets the window to full-screen mode.
		 *
		 * @param displayMode the display mode.
		 * @return whether the operation succeeded. */
		bool SetFullscreenMode(DisplayMode displayMode);

		/** Sets the window to windowed mode.
		 *
		 * @param width the width in pixels
		 * @param height the height in pixels
		 * @return whether the operation succeeded */
		bool SetWindowedMode(int width, int height);

		/** Sets the title of the window. Ignored on Android.
		 *
		 * @param title the title. */
		void SetTitle(String title);

		/** Sets the window decoration as enabled or disabled. On Android, this will enable/disable the menu bar.
		 *
		 * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
		 * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
		 *
		 * Supported on all GDX desktop backends and on Android (to disable the menu bar).
		 *
		 * @param undecorated true if the window border or status bar should be hidden. false otherwise. */
		void SetUndecorated(bool undecorated);

		/** Sets whether or not the window should be resizable. Ignored on Android.
		 *
		 * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
		 * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
		 *
		 * Supported on all GDX desktop backends.
		 *
		 * @param resizable */
		void SetResizable(bool resizable);

		/** Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.
		 *
		 * @param vsync vsync enabled or not. */
		void SetVSync(bool vsync);

		/** Sets the target framerate for the application when using continuous rendering. Might not work on all platforms. Is not
		 * generally advised to be used on mobile platforms.
		 *
		 * @param fps the targeted fps; default differs by platform */
		public void SetForegroundFPS(int fps);

		/** @return the format of the color, depth and stencil buffer in a {@link BufferFormat} instance */
		BufferFormat GetBufferFormat();

		/** @param extension the extension name
		 * @return whether the extension is supported */
		bool SupportsExtension(String extension);

		/** Sets whether to render continuously. In case rendering is performed non-continuously, the following events will trigger a
		 * redraw:
		 *
		 * <ul>
		 * <li>A call to {@link #requestRendering()}</li>
		 * <li>Input events from the touch screen/mouse or keyboard</li>
		 * <li>A {@link Runnable} is posted to the rendering thread via {@link Application#postRunnable(Runnable)}. In the case of a
		 * multi-window app, all windows will request rendering if a runnable is posted to the application. To avoid this, post a
		 * runnable to the window instead.</li>
		 * </ul>
		 *
		 * Life-cycle events will also be reported as usual, see {@link ApplicationListener}. This method can be called from any
		 * thread.
		 *
		 * @param isContinuous whether the rendering should be continuous or not. */
		void SetContinuousRendering(bool isContinuous);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Whether rendering is continuous.</returns>
        bool IsContinuousRendering();

        /// <summary>
        /// Requests a new frame to be rendered if the rendering mode is non-continuous.
        /// </summary>
        /// <remarks>
        ///This method can be called from any thread.
        /// </remarks>
        void RequestRendering();

        /// <summary>
        /// Whether the app is fullscreen or not.
        /// </summary>
        /// <returns></returns>
        bool IsFullscreen();

		/** Create a new cursor represented by the {@link com.badlogic.gdx.graphics.Pixmap}. The Pixmap must be in RGBA8888 format,
		 * width & height must be powers-of-two greater than zero (not necessarily equal) and of a certain minimum size (32x32 is a
		 * safe bet), and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). This function returns a Cursor object that
		 * can be set as the system cursor by calling {@link #setCursor(Cursor)} .
		 *
		 * @param pixmap the mouse cursor image as a {@link com.badlogic.gdx.graphics.Pixmap}
		 * @param xHotspot the x location of the hotspot pixel within the cursor image (origin top-left corner)
		 * @param yHotspot the y location of the hotspot pixel within the cursor image (origin top-left corner)
		 * @return a cursor object that can be used by calling {@link #setCursor(Cursor)} or null if not supported */
		ICursor NewCursor(Pixmap pixmap, int xHotspot, int yHotspot);

		/** Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the
		 * pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to
		 * the image represented by the {@link com.badlogic.gdx.graphics.Cursor}. It is recommended to call this function in the main
		 * render thread, and maximum one time per frame.
		 *
		 * @param cursor the mouse cursor as a {@link com.badlogic.gdx.graphics.Cursor} */
		void SetCursor(ICursor cursor);

        /// <summary>
        /// Sets one of the predefined <see cref="ICursor.SystemCursor"/>s.
        /// </summary>
        /// <param name="systemCursor"></param>
        void SetSystemCursor(ICursor.SystemCursor systemCursor);
	}
}
